diff --git a/examples/companion_radio/MyMesh.cpp b/examples/companion_radio/MyMesh.cpp
index 09d866c..fbdd095 100644
--- a/examples/companion_radio/MyMesh.cpp
+++ b/examples/companion_radio/MyMesh.cpp
@@ -473,6 +473,10 @@ void MyMesh::onChannelMessageRecv(const mesh::GroupChannel &channel, mesh::Packe
     if (_ui) _ui->notify(UIEventType::channelMessage);
 #endif
   }
+  
+  // Send packet to TCP clients
+  sendPacketToTcpClients(pkt);
+  
 #ifdef DISPLAY_CLASS
   // Get the channel name from the channel index
   const char *channel_name = "Unknown";
@@ -673,6 +677,9 @@ void MyMesh::onRawDataRecv(mesh::Packet *packet) {
   } else {
     MESH_DEBUG_PRINTLN("onRawDataRecv(), data received while app offline");
   }
+  
+  // Send packet to TCP clients
+  sendPacketToTcpClients(packet);
 }
 
 void MyMesh::onTraceRecv(mesh::Packet *packet, uint32_t tag, uint32_t auth_code, uint8_t flags,
@@ -729,6 +736,10 @@ MyMesh::MyMesh(mesh::Radio &radio, mesh::RNG &rng, mesh::RTCClock &rtc, SimpleMe
   dirty_contacts_expiry = 0;
   memset(advert_paths, 0, sizeof(advert_paths));
   memset(send_scope.key, 0, sizeof(send_scope.key));
+  
+  // Raw packet server initialization
+  _raw_packet_server = NULL;
+  _raw_rx_pos = 0;
 
   // defaults
   memset(&_prefs, 0, sizeof(_prefs));
@@ -803,6 +814,8 @@ void MyMesh::begin(bool has_display) {
 
   radio_set_params(_prefs.freq, _prefs.bw, _prefs.sf, _prefs.cr);
   radio_set_tx_power(_prefs.tx_power_dbm);
+  
+  // Note: Raw packet server initialization moved to loop() for lazy init
 }
 
 const char *MyMesh::getNodeName() {
@@ -1840,6 +1853,19 @@ void MyMesh::loop() {
   } else {
     checkSerialInterface();
   }
+  
+  // Lazy initialize raw packet server on first loop
+  if (_raw_packet_server == NULL) {
+    _raw_packet_server = new WiFiServer(5002);
+    if (_raw_packet_server) {
+      _raw_packet_server->begin();
+      _raw_rx_pos = 0;
+      MESH_DEBUG_PRINTLN("Raw packet server started on port 5002");
+    }
+  }
+  
+  // Handle raw packet server (TCP port 5002)
+  handleRawPacketServer();
 
   // is there are pending dirty contacts write needed?
   if (dirty_contacts_expiry && millisHasNowPassed(dirty_contacts_expiry)) {
@@ -1865,4 +1891,275 @@ bool MyMesh::advert() {
   } else {
     return false;
   }
-}
\ No newline at end of file
+}
+// ===================== RAW PACKET SERVER (TCP 5002) =====================
+
+// Note: WiFiServer initialization is now done lazily in loop() to ensure
+// TCP/IP stack is ready (avoids "Invalid mbox" errors from lwIP)
+
+void MyMesh::handleRawPacketServer() {
+  if (_raw_packet_server == NULL) return;
+  
+  // Accept new client connection
+  if (!_raw_packet_client.connected()) {
+    _raw_packet_client = _raw_packet_server->available();
+    if (_raw_packet_client) {
+      _raw_rx_pos = 0;
+      MESH_DEBUG_PRINTLN("Raw packet client connected");
+    }
+    return;
+  }
+  
+  // Read available data from client
+  while (_raw_packet_client.available()) {
+    if (_raw_rx_pos >= sizeof(_raw_rx_buffer)) {
+      // Buffer full, drop oldest data
+      memcpy(_raw_rx_buffer, _raw_rx_buffer + 256, sizeof(_raw_rx_buffer) - 256);
+      _raw_rx_pos = sizeof(_raw_rx_buffer) - 256;
+    }
+    
+    int byte = _raw_packet_client.read();
+    if (byte >= 0) {
+      _raw_rx_buffer[_raw_rx_pos++] = (uint8_t)byte;
+      
+      // Try to parse packet if we have enough data
+      if (_raw_rx_pos >= 6) {  // Minimum: 2B magic + 2B length + payload + 2B checksum
+        uint16_t magic = (_raw_rx_buffer[0] << 8) | _raw_rx_buffer[1];
+        if (magic == 0xC03E) {
+          uint16_t length = (_raw_rx_buffer[2] << 8) | _raw_rx_buffer[3];
+          int total_frame_size = 6 + length;  // 2B magic + 2B length + payload + 2B checksum
+          
+          if (_raw_rx_pos >= total_frame_size) {
+            // We have a complete frame
+            mesh::Packet *pkt = NULL;
+            if (parseRS232BridgePacket(_raw_rx_buffer, total_frame_size, pkt)) {
+              if (pkt) {
+                MESH_DEBUG_PRINTLN("Injecting virtual packet to mesh (FLOOD mode)");
+                displayReceivedPacket(pkt);  // Display received packet info
+                sendFlood(pkt);  // Send in FLOOD mode
+              }
+            } else {
+              MESH_DEBUG_PRINTLN("Failed to parse RS232Bridge packet");
+            }
+            
+            // Remove processed frame from buffer
+            memcpy(_raw_rx_buffer, _raw_rx_buffer + total_frame_size, _raw_rx_pos - total_frame_size);
+            _raw_rx_pos -= total_frame_size;
+          }
+        } else {
+          // Invalid magic, try to resync
+          MESH_DEBUG_PRINTLN("Invalid magic byte, resyncing...");
+          _raw_rx_pos = 0;
+        }
+      }
+    }
+  }
+  
+  // Check if client disconnected
+  if (!_raw_packet_client.connected()) {
+    _raw_packet_client.stop();
+    _raw_rx_pos = 0;
+    MESH_DEBUG_PRINTLN("Raw packet client disconnected");
+  }
+}
+
+bool MyMesh::parseRS232BridgePacket(const uint8_t *data, int len, mesh::Packet*& pkt_out) {
+  pkt_out = NULL;
+  
+  if (len < 6) return false;  // Too short
+  
+  // Verify magic (0xC03E)
+  uint16_t magic = (data[0] << 8) | data[1];
+  if (magic != 0xC03E) {
+    MESH_DEBUG_PRINTLN("Invalid magic: 0x%04X", magic);
+    return false;
+  }
+  
+  // Get length
+  uint16_t payload_len = (data[2] << 8) | data[3];
+  if (len != 6 + payload_len) {
+    MESH_DEBUG_PRINTLN("Length mismatch: expected %d, got %d", 6 + payload_len, len);
+    return false;
+  }
+  
+  // Get checksum from packet
+  uint16_t received_checksum = (data[4 + payload_len] << 8) | data[5 + payload_len];
+  
+  // Calculate Fletcher-16 checksum on payload
+  uint16_t sum1 = 0, sum2 = 0;
+  const uint8_t *payload = data + 4;
+  for (int i = 0; i < payload_len; i++) {
+    sum1 = (sum1 + payload[i]) % 255;
+    sum2 = (sum2 + sum1) % 255;
+  }
+  uint16_t calculated_checksum = (sum2 << 8) | sum1;
+  
+  if (calculated_checksum != received_checksum) {
+    MESH_DEBUG_PRINTLN("Checksum mismatch: expected 0x%04X, got 0x%04X", calculated_checksum, received_checksum);
+    return false;
+  }
+  
+  // Parse packet from payload
+  pkt_out = _mgr->allocNew();
+  if (!pkt_out) {
+    MESH_DEBUG_PRINTLN("Failed to allocate packet");
+    return false;
+  }
+  
+  // Debug: show payload hex
+  MESH_DEBUG_PRINT("Payload hex (%d bytes): ", payload_len);
+  for (int i = 0; i < payload_len && i < 32; i++) {
+    MESH_DEBUG_PRINT("%02X ", payload[i]);
+  }
+  MESH_DEBUG_PRINTLN("");
+  
+  // Copy payload to packet buffer
+  if (!pkt_out->readFrom(payload, payload_len)) {
+    MESH_DEBUG_PRINTLN("Failed to read packet data (payload_len=%d)", payload_len);
+    _mgr->free(pkt_out);
+    pkt_out = NULL;
+    return false;
+  }
+  
+  MESH_DEBUG_PRINTLN("Parsed RS232Bridge packet: %d bytes", payload_len);
+  return true;
+}
+
+void MyMesh::displayReceivedPacket(const mesh::Packet *pkt) {
+  if (pkt == NULL) return;
+  
+  // Extract packet information
+  uint8_t route_type = pkt->getRouteType();
+  uint8_t payload_type = pkt->getPayloadType();
+  
+  // Route type string
+  const char *route_str;
+  switch(route_type) {
+    case 0x00: route_str = "TRANSPORT_FLOOD"; break;
+    case 0x01: route_str = "FLOOD"; break;
+    case 0x02: route_str = "DIRECT"; break;
+    case 0x03: route_str = "TRANSPORT_DIRECT"; break;
+    default: route_str = "UNKNOWN"; break;
+  }
+  
+  // Payload type string
+  const char *type_str;
+  switch(payload_type) {
+    case 0x00: type_str = "REQ"; break;
+    case 0x01: type_str = "RESPONSE"; break;
+    case 0x02: type_str = "TXT_MSG"; break;
+    case 0x03: type_str = "ACK"; break;
+    case 0x04: type_str = "ADVERT"; break;
+    case 0x05: type_str = "GRP_TXT"; break;
+    case 0x06: type_str = "GRP_DATA"; break;
+    case 0x07: type_str = "ANON_REQ"; break;
+    case 0x08: type_str = "PATH"; break;
+    case 0x09: type_str = "TRACE"; break;
+    case 0x0A: type_str = "MULTIPART"; break;
+    case 0x0B: type_str = "CONTROL"; break;
+    case 0x0F: type_str = "RAW_CUSTOM"; break;
+    default: type_str = "UNKNOWN"; break;
+  }
+  
+  Serial.printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
+  Serial.printf("ðŸ“¦ RECEIVED PACKET FROM TCP (5002)\n");
+  Serial.printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
+  Serial.printf("Header:       0x%02X\n", pkt->header);
+  Serial.printf("  Route:      %s (0x%02X)\n", route_str, route_type);
+  Serial.printf("  Type:       %s (0x%02X)\n", type_str, payload_type);
+  Serial.printf("  Version:    0x%02X\n", pkt->getPayloadVer());
+  Serial.printf("Path length:  %d bytes\n", pkt->path_len);
+  Serial.printf("Payload len:  %d bytes\n", pkt->payload_len);
+  
+  // Display path if present
+  if (pkt->path_len > 0) {
+    Serial.printf("Path:         ");
+    for (int i = 0; i < pkt->path_len; i++) {
+      Serial.printf("%02X ", pkt->path[i]);
+    }
+    Serial.printf("\n");
+  }
+  
+  // Display payload hex (first 64 bytes)
+  Serial.printf("Payload hex:  ");
+  int display_len = (pkt->payload_len > 64) ? 64 : pkt->payload_len;
+  for (int i = 0; i < display_len; i++) {
+    Serial.printf("%02X ", pkt->payload[i]);
+    if ((i + 1) % 16 == 0 && i < display_len - 1) {
+      Serial.printf("\n              ");
+    }
+  }
+  if (pkt->payload_len > 64) {
+    Serial.printf("... (%d more bytes)", pkt->payload_len - 64);
+  }
+  Serial.printf("\n");
+  
+  // Try to parse GRP_TXT payload
+  if (payload_type == 0x05 && pkt->payload_len > 3) {  // GRP_TXT
+    uint8_t channel_hash = pkt->payload[0];
+    Serial.printf("\nGroup Message Details:\n");
+    Serial.printf("  Channel hash: 0x%02X\n", channel_hash);
+    
+    // MAC is bytes 1-2
+    uint16_t mac = (pkt->payload[1] << 8) | pkt->payload[2];
+    Serial.printf("  MAC:          0x%04X\n", mac);
+    
+    Serial.printf("  Encrypted:    %d bytes (compressed)\n", pkt->payload_len - 3);
+    
+    // Try to find which channel this is (iterate through available channels)
+    for (int i = 0; i < 16; i++) {  // Max channels
+      ChannelDetails ch;
+      if (getChannel(i, ch) && ch.channel.hash[0] == channel_hash) {
+        Serial.printf("  â†’ Matched to: '%s' channel\n", ch.name);
+        break;
+      }
+    }
+  }
+  
+  Serial.printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");
+}
+
+void MyMesh::sendPacketToTcpClients(const mesh::Packet *pkt) {
+  if (pkt == NULL) return;
+  if (!_raw_packet_client.connected()) return;
+  
+  // Serialize packet to wire format
+  uint8_t packet_buffer[256];
+  uint8_t packet_len = pkt->writeTo(packet_buffer);
+  
+  // Build RS232Bridge frame
+  uint8_t frame[512];
+  int frame_pos = 0;
+  
+  // Magic
+  frame[frame_pos++] = 0xC0;
+  frame[frame_pos++] = 0x3E;
+  
+  // Length (big-endian)
+  frame[frame_pos++] = (packet_len >> 8) & 0xFF;
+  frame[frame_pos++] = packet_len & 0xFF;
+  
+  // Packet data
+  memcpy(&frame[frame_pos], packet_buffer, packet_len);
+  frame_pos += packet_len;
+  
+  // Calculate Fletcher-16 checksum
+  uint16_t sum1 = 0, sum2 = 0;
+  for (int i = 0; i < packet_len; i++) {
+    sum1 = (sum1 + packet_buffer[i]) % 255;
+    sum2 = (sum2 + sum1) % 255;
+  }
+  
+  // Checksum (sum2, sum1 order)
+  frame[frame_pos++] = sum2;
+  frame[frame_pos++] = sum1;
+  
+  // Send to TCP client
+  int bytes_sent = _raw_packet_client.write(frame, frame_pos);
+  
+  if (bytes_sent != frame_pos) {
+    MESH_DEBUG_PRINTLN("TCP send error: sent %d/%d bytes", bytes_sent, frame_pos);
+  } else {
+    MESH_DEBUG_PRINTLN("TCP TX: sent %d bytes to client", frame_pos);
+  }
+}
