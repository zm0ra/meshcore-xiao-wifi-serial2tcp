diff --git a/examples/companion_radio/MyMesh.cpp b/examples/companion_radio/MyMesh.cpp
index 09d866c..8b45e0a 100644
--- a/examples/companion_radio/MyMesh.cpp
+++ b/examples/companion_radio/MyMesh.cpp
@@ -473,6 +473,9 @@ void MyMesh::onChannelMessageRecv(const mesh::GroupChannel &channel, mesh::Packe
     if (_ui) _ui->notify(UIEventType::channelMessage);
 #endif
   }
+  
+  // Relay to TCP clients via SerialWifiInterface
+  relayPacketToTcp(pkt);
 #ifdef DISPLAY_CLASS
   // Get the channel name from the channel index
   const char *channel_name = "Unknown";
@@ -673,6 +676,9 @@ void MyMesh::onRawDataRecv(mesh::Packet *packet) {
   } else {
     MESH_DEBUG_PRINTLN("onRawDataRecv(), data received while app offline");
   }
+  
+  // Relay to TCP clients via SerialWifiInterface
+  relayPacketToTcp(packet);
 }
 
 void MyMesh::onTraceRecv(mesh::Packet *packet, uint32_t tag, uint32_t auth_code, uint8_t flags,
@@ -729,6 +735,7 @@ MyMesh::MyMesh(mesh::Radio &radio, mesh::RNG &rng, mesh::RTCClock &rtc, SimpleMe
   dirty_contacts_expiry = 0;
   memset(advert_paths, 0, sizeof(advert_paths));
   memset(send_scope.key, 0, sizeof(send_scope.key));
+  _tcp_relay_enabled = false;
 
   // defaults
   memset(&_prefs, 0, sizeof(_prefs));
@@ -803,6 +810,8 @@ void MyMesh::begin(bool has_display) {
 
   radio_set_params(_prefs.freq, _prefs.bw, _prefs.sf, _prefs.cr);
   radio_set_tx_power(_prefs.tx_power_dbm);
+  
+  // TCP relay will be enabled after serial interface is ready
 }
 
 const char *MyMesh::getNodeName() {
@@ -840,6 +849,9 @@ void MyMesh::startInterface(BaseSerialInterface &serial) {
 void MyMesh::startInterface(BaseSerialInterface &serial) {
   _serial = &serial;
   serial.enable();
+  
+  // Enable TCP relay once SerialWifiInterface is active
+  _tcp_relay_enabled = true;
 }
 
 void MyMesh::handleCmdFrame(size_t len) {
@@ -1865,4 +1877,32 @@ bool MyMesh::advert() {
   } else {
     return false;
   }
-}
\ No newline at end of file
+}
+
+// ===================== TCP RELAY HELPERS =====================
+// Relay received packets to TCP clients via SerialWifiInterface
+
+void MyMesh::relayPacketToTcp(const mesh::Packet *pkt) {
+  if (pkt == NULL) return;
+  if (!_tcp_relay_enabled || !_serial) return;
+  if (!_serial->isConnected()) return;
+  
+  // Serialize packet to wire format
+  uint8_t packet_buffer[256];
+  uint8_t packet_len = pkt->writeTo(packet_buffer);
+  
+  if (packet_len == 0 || packet_len > 250) {
+    MESH_DEBUG_PRINTLN("Packet relay skipped: invalid length %d", packet_len);
+    return;
+  }
+  
+  // Send via _serial interface (RS232Bridge frame wrapper)
+  // The SerialWifiInterface will wrap this in RS232Bridge format
+  size_t sent = _serial->writeFrame(packet_buffer, packet_len);
+  
+  if (sent != packet_len) {
+    MESH_DEBUG_PRINTLN("Packet relay partial: sent %d/%d bytes", sent, packet_len);
+  } else {
+    MESH_DEBUG_PRINTLN("Packet relayed: %d bytes to TCP client", packet_len);
+  }
+}
